{
    "collab_server" : "",
    "contents" : "#' Performs Clarke-Wright Savings algorithm in Sequential\n#' @param Sort_Edge -- Edges sorted in a decreasing order with respect to savings\n#' @param nnodes -- Number of customer nodes (Excluding depot)\n#' @export\n\nCW_Sequential_VRP <- function(Sort_Edge, nnodes, routes = list(), Served_nodes = c(), Filled_Routes = c(), logfile = TRUE){\n  \n  if(logfile){\n    if(is.null(Served_nodes)){ # Delete \n      if(file.exists(\"Results_Seq.txt\")) file.remove(\"Results_Seq.txt\")\n    }\n    out <- capture.output(routes)\n    cat(\"Route: \", out, file = \"Results_Seq.txt\", sep = \"\\n\", append = TRUE)\n  }\n  \n  if(length(Served_nodes) == nnodes | nrow(Sort_Edge) == 0){ # If all the nodes are serviced then return routes\n    cat(\"Number of nodes serviced := \", length(Served_nodes), \"\\n\")\n    if(length(Served_nodes) < nnodes) cat(\"Infeasible nodes: \", setdiff(c(2:(nnodes+1)), Served_nodes), \"\\n\")\n    return(routes)\n  }\n  \n  CommonNode <- intersect(c(Sort_Edge[1, 1], Sort_Edge[1, 2]), Served_nodes)\n  NewNode <- setdiff(c(Sort_Edge[1, 1], Sort_Edge[1, 2]), CommonNode)\n  nCommonNodes <- length(CommonNode)\n  \n  if(nCommonNodes == 0){ # If there is no common node between new edge and existing routes then create a new route\n    x <- Find_Ind_Common_Edge(Sort_Edge, Served_nodes)\n    if(x == 0){\n      routes[[length(routes) + 1]] <- c(Sort_Edge[1, 1], Sort_Edge[1, 2])\n      Served_nodes <- unique(c(Served_nodes, c(Sort_Edge[1, 1], Sort_Edge[1, 2])))\n      return(CW_Sequential_VRP(Sort_Edge[-1, ], nnodes, routes = routes, Served_nodes = Served_nodes))\n    }else{\n      Sort_Edge2 <- Sort_Edge\n      Sort_Edge[1, ] <- Sort_Edge2[x, ]\n      Sort_Edge[x, ] <- Sort_Edge2[1, ]\n      # Sort_Edge <- Sort_Edge[c(x, c(2:(x-1)), c(1, (x+1) : nrow(Sort_Edge))), ]\n      return(CW_Sequential_VRP(Sort_Edge, nnodes, routes = routes, Served_nodes = Served_nodes))\n    }\n  }else if(nCommonNodes == 1){ # If there is exactly one common node between new edge and existing routes then check the constraints validation and connect the edges\n    route_id <- 0\n    # Find route id in which common node exists \n    for(i in 1:length(routes)){\n      if(CommonNode %in% routes[[i]]) route_id <- i\n    }\n    # If route is already filled then continue with the other edges\n    if(route_id %in% Filled_Routes){\n      return(CW_Sequential_VRP(Sort_Edge[-1, ], nnodes, routes = routes, Served_nodes = Served_nodes))\n    }\n    # Check whether common node is interior or not? And if it is interior delete the first edge and continue \n    if(isInterior(routes[[route_id]], CommonNode)){\n      return(CW_Sequential_VRP(Sort_Edge[-1, ], nnodes, routes = routes, Served_nodes = Served_nodes))\n    }\n    \n    CC <- CheckConstraints(routes[[route_id]], CommonNode, NewNode, Constraints = c(\"Capacity\"))\n    if(CC$Filled) Filled_Routes <- c(Filled_Routes, route_id)\n    \n    # Check whenther including new node to existing route satisfying constraints or not? If it satisfies include new node into route, otherwise delete the first edge and continue\n    if(CC$Satisfied){\n      routes[[route_id]] <- Connect_Edges(route = routes[[route_id]], common_node = CommonNode, new_node = NewNode)\n      Served_nodes <- c(Served_nodes, NewNode)\n      return(CW_Sequential_VRP(Sort_Edge[-1, ], nnodes, routes = routes, Served_nodes = Served_nodes))\n    }else{\n      return(CW_Sequential_VRP(Sort_Edge[-1, ], nnodes, routes = routes, Served_nodes = Served_nodes))\n    }\n  }else if(nCommonNodes == 2){ # If both the nodes are common then remove the edge from the Sort_Edge\n    return(CW_Sequential_VRP(Sort_Edge[-1, ], nnodes, routes = routes, Served_nodes = Served_nodes))\n  }\n}",
    "created" : 1485064946980.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2735712307",
    "id" : "21B4ED9",
    "lastKnownWriteTime" : 1485071531,
    "last_content_update" : 1485071531273,
    "path" : "~/Clarke_Wright_Savings_Algo/R/SequentialRouting.R",
    "project_path" : "R/SequentialRouting.R",
    "properties" : {
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}