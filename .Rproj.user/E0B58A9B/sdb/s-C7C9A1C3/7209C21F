{
    "collab_server" : "",
    "contents" : "#' Performs Clarke-Wright Savings algorithm in Parallel\n#' @param Sort_Edge -- Edges sorted in a decreasing order of their savings\n#' @param nnodes -- Number of customer nodes\n#' @export\n\nCW_Parallel_VRP <- function(Sort_Edge, nnodes, routes = list(), Served_nodes = c(), Filled_Routes = c(), logfile = TRUE){\n  # If all the nodes are serviced then return routes\n  if(logfile){\n    if(is.null(Served_nodes)){\n      if(file.exists(\"Results.txt\")) file.remove(\"Results.txt\")\n    }\n    out <- capture.output(routes)\n    cat(\"Route: \", out, file = \"Results.txt\", sep = \"\\n\", append = TRUE)\n  }\n  \n  if(length(Served_nodes) == nnodes | nrow(Sort_Edge) == 0){\n    cat(\"Number of nodes serviced := \", length(Served_nodes), \"\\n\")\n    return(routes)\n  }\n  \n  CommonNode <- intersect(c(Sort_Edge[1, 1], Sort_Edge[1, 2]), Served_nodes)\n  NewNode <- setdiff(c(Sort_Edge[1, 1], Sort_Edge[1, 2]), CommonNode)\n  nCommonNodes <- length(CommonNode)\n  \n  if(nCommonNodes == 0){ # If there is no common node between new edge and existing routes then create a new route\n    \n    routes[[length(routes) + 1]] <- c(Sort_Edge[1, 1], Sort_Edge[1, 2])\n    Served_nodes <- unique(c(Served_nodes, c(Sort_Edge[1, 1], Sort_Edge[1, 2])))\n    return(CW_Parallel_VRP(Sort_Edge[-1, ], nnodes, routes = routes, Served_nodes = Served_nodes))\n    \n  }else if(nCommonNodes == 1){ # If there is exactly one common node between new edge and existing routes then check the constraints validation and connect the edges\n    route_id <- 0\n    # Find route id in which common node exists \n    for(i in 1:length(routes)){\n      if(CommonNode %in% routes[[i]]) route_id <- i\n    }\n    # If route is already filled then continue with the other edges\n    if(route_id %in% Filled_Routes){\n      return(CW_Parallel_VRP(Sort_Edge[-1, ], nnodes, routes = routes, Served_nodes = Served_nodes))\n    }\n    # Check whether common node is interior or not? And if it is interior delete the first edge and continue \n    if(isInterior(routes[[route_id]], CommonNode)){\n      return(CW_Parallel_VRP(Sort_Edge[-1, ], nnodes, routes = routes, Served_nodes = Served_nodes))\n    }\n    \n    CC <- CheckConstraints(routes[[route_id]], CommonNode, NewNode, Constraints = c(\"Capacity\"))\n    if(CC$Filled) Filled_Routes <- c(Filled_Routes, route_id)\n    \n    # Check whenther including new node to existing route satisfying constraints or not? If it satisfies include new node into route, otherwise delete the first edge and continue\n    if(CC$Satisfied){\n      routes[[route_id]] <- Connect_Edges(route = routes[[route_id]], common_node = CommonNode, new_node = NewNode)\n      Served_nodes <- c(Served_nodes, NewNode)\n      return(CW_Parallel_VRP(Sort_Edge[-1, ], nnodes, routes = routes, Served_nodes = Served_nodes))\n    }else{\n      return(CW_Parallel_VRP(Sort_Edge[-1, ], nnodes, routes = routes, Served_nodes = Served_nodes))\n    }\n  }else if(nCommonNodes == 2){ # If both the nodes are common then remove the edge from the Sort_Edge\n    return(CW_Parallel_VRP(Sort_Edge[-1, ], nnodes, routes = routes, Served_nodes = Served_nodes))\n  }\n}",
    "created" : 1485067388134.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3377430634",
    "id" : "7209C21F",
    "lastKnownWriteTime" : 1485068145,
    "last_content_update" : 1485068145084,
    "path" : "~/Clarke_Wright_Savings_Algo/R/ParallelRouting.R",
    "project_path" : "R/ParallelRouting.R",
    "properties" : {
    },
    "relative_order" : 7,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}